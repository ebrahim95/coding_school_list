{
  "resolvedId": "/home/ebrahim/Desktop/coding_school_list/web_app/node_modules/.vite/deps/@tanstack_match-sorter-utils.js?v=7d850d6b",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "// node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs\nvar characterMap = {\n  À: \"A\",\n  Á: \"A\",\n  Â: \"A\",\n  Ã: \"A\",\n  Ä: \"A\",\n  Å: \"A\",\n  Ấ: \"A\",\n  Ắ: \"A\",\n  Ẳ: \"A\",\n  Ẵ: \"A\",\n  Ặ: \"A\",\n  Æ: \"AE\",\n  Ầ: \"A\",\n  Ằ: \"A\",\n  Ȃ: \"A\",\n  Ç: \"C\",\n  Ḉ: \"C\",\n  È: \"E\",\n  É: \"E\",\n  Ê: \"E\",\n  Ë: \"E\",\n  Ế: \"E\",\n  Ḗ: \"E\",\n  Ề: \"E\",\n  Ḕ: \"E\",\n  Ḝ: \"E\",\n  Ȇ: \"E\",\n  Ì: \"I\",\n  Í: \"I\",\n  Î: \"I\",\n  Ï: \"I\",\n  Ḯ: \"I\",\n  Ȋ: \"I\",\n  Ð: \"D\",\n  Ñ: \"N\",\n  Ò: \"O\",\n  Ó: \"O\",\n  Ô: \"O\",\n  Õ: \"O\",\n  Ö: \"O\",\n  Ø: \"O\",\n  Ố: \"O\",\n  Ṍ: \"O\",\n  Ṓ: \"O\",\n  Ȏ: \"O\",\n  Ù: \"U\",\n  Ú: \"U\",\n  Û: \"U\",\n  Ü: \"U\",\n  Ý: \"Y\",\n  à: \"a\",\n  á: \"a\",\n  â: \"a\",\n  ã: \"a\",\n  ä: \"a\",\n  å: \"a\",\n  ấ: \"a\",\n  ắ: \"a\",\n  ẳ: \"a\",\n  ẵ: \"a\",\n  ặ: \"a\",\n  æ: \"ae\",\n  ầ: \"a\",\n  ằ: \"a\",\n  ȃ: \"a\",\n  ç: \"c\",\n  ḉ: \"c\",\n  è: \"e\",\n  é: \"e\",\n  ê: \"e\",\n  ë: \"e\",\n  ế: \"e\",\n  ḗ: \"e\",\n  ề: \"e\",\n  ḕ: \"e\",\n  ḝ: \"e\",\n  ȇ: \"e\",\n  ì: \"i\",\n  í: \"i\",\n  î: \"i\",\n  ï: \"i\",\n  ḯ: \"i\",\n  ȋ: \"i\",\n  ð: \"d\",\n  ñ: \"n\",\n  ò: \"o\",\n  ó: \"o\",\n  ô: \"o\",\n  õ: \"o\",\n  ö: \"o\",\n  ø: \"o\",\n  ố: \"o\",\n  ṍ: \"o\",\n  ṓ: \"o\",\n  ȏ: \"o\",\n  ù: \"u\",\n  ú: \"u\",\n  û: \"u\",\n  ü: \"u\",\n  ý: \"y\",\n  ÿ: \"y\",\n  Ā: \"A\",\n  ā: \"a\",\n  Ă: \"A\",\n  ă: \"a\",\n  Ą: \"A\",\n  ą: \"a\",\n  Ć: \"C\",\n  ć: \"c\",\n  Ĉ: \"C\",\n  ĉ: \"c\",\n  Ċ: \"C\",\n  ċ: \"c\",\n  Č: \"C\",\n  č: \"c\",\n  C̆: \"C\",\n  c̆: \"c\",\n  Ď: \"D\",\n  ď: \"d\",\n  Đ: \"D\",\n  đ: \"d\",\n  Ē: \"E\",\n  ē: \"e\",\n  Ĕ: \"E\",\n  ĕ: \"e\",\n  Ė: \"E\",\n  ė: \"e\",\n  Ę: \"E\",\n  ę: \"e\",\n  Ě: \"E\",\n  ě: \"e\",\n  Ĝ: \"G\",\n  Ǵ: \"G\",\n  ĝ: \"g\",\n  ǵ: \"g\",\n  Ğ: \"G\",\n  ğ: \"g\",\n  Ġ: \"G\",\n  ġ: \"g\",\n  Ģ: \"G\",\n  ģ: \"g\",\n  Ĥ: \"H\",\n  ĥ: \"h\",\n  Ħ: \"H\",\n  ħ: \"h\",\n  Ḫ: \"H\",\n  ḫ: \"h\",\n  Ĩ: \"I\",\n  ĩ: \"i\",\n  Ī: \"I\",\n  ī: \"i\",\n  Ĭ: \"I\",\n  ĭ: \"i\",\n  Į: \"I\",\n  į: \"i\",\n  İ: \"I\",\n  ı: \"i\",\n  Ĳ: \"IJ\",\n  ĳ: \"ij\",\n  Ĵ: \"J\",\n  ĵ: \"j\",\n  Ķ: \"K\",\n  ķ: \"k\",\n  Ḱ: \"K\",\n  ḱ: \"k\",\n  K̆: \"K\",\n  k̆: \"k\",\n  Ĺ: \"L\",\n  ĺ: \"l\",\n  Ļ: \"L\",\n  ļ: \"l\",\n  Ľ: \"L\",\n  ľ: \"l\",\n  Ŀ: \"L\",\n  ŀ: \"l\",\n  Ł: \"l\",\n  ł: \"l\",\n  Ḿ: \"M\",\n  ḿ: \"m\",\n  M̆: \"M\",\n  m̆: \"m\",\n  Ń: \"N\",\n  ń: \"n\",\n  Ņ: \"N\",\n  ņ: \"n\",\n  Ň: \"N\",\n  ň: \"n\",\n  ŉ: \"n\",\n  N̆: \"N\",\n  n̆: \"n\",\n  Ō: \"O\",\n  ō: \"o\",\n  Ŏ: \"O\",\n  ŏ: \"o\",\n  Ő: \"O\",\n  ő: \"o\",\n  Œ: \"OE\",\n  œ: \"oe\",\n  P̆: \"P\",\n  p̆: \"p\",\n  Ŕ: \"R\",\n  ŕ: \"r\",\n  Ŗ: \"R\",\n  ŗ: \"r\",\n  Ř: \"R\",\n  ř: \"r\",\n  R̆: \"R\",\n  r̆: \"r\",\n  Ȓ: \"R\",\n  ȓ: \"r\",\n  Ś: \"S\",\n  ś: \"s\",\n  Ŝ: \"S\",\n  ŝ: \"s\",\n  Ş: \"S\",\n  Ș: \"S\",\n  ș: \"s\",\n  ş: \"s\",\n  Š: \"S\",\n  š: \"s\",\n  Ţ: \"T\",\n  ţ: \"t\",\n  ț: \"t\",\n  Ț: \"T\",\n  Ť: \"T\",\n  ť: \"t\",\n  Ŧ: \"T\",\n  ŧ: \"t\",\n  T̆: \"T\",\n  t̆: \"t\",\n  Ũ: \"U\",\n  ũ: \"u\",\n  Ū: \"U\",\n  ū: \"u\",\n  Ŭ: \"U\",\n  ŭ: \"u\",\n  Ů: \"U\",\n  ů: \"u\",\n  Ű: \"U\",\n  ű: \"u\",\n  Ų: \"U\",\n  ų: \"u\",\n  Ȗ: \"U\",\n  ȗ: \"u\",\n  V̆: \"V\",\n  v̆: \"v\",\n  Ŵ: \"W\",\n  ŵ: \"w\",\n  Ẃ: \"W\",\n  ẃ: \"w\",\n  X̆: \"X\",\n  x̆: \"x\",\n  Ŷ: \"Y\",\n  ŷ: \"y\",\n  Ÿ: \"Y\",\n  Y̆: \"Y\",\n  y̆: \"y\",\n  Ź: \"Z\",\n  ź: \"z\",\n  Ż: \"Z\",\n  ż: \"z\",\n  Ž: \"Z\",\n  ž: \"z\",\n  ſ: \"s\",\n  ƒ: \"f\",\n  Ơ: \"O\",\n  ơ: \"o\",\n  Ư: \"U\",\n  ư: \"u\",\n  Ǎ: \"A\",\n  ǎ: \"a\",\n  Ǐ: \"I\",\n  ǐ: \"i\",\n  Ǒ: \"O\",\n  ǒ: \"o\",\n  Ǔ: \"U\",\n  ǔ: \"u\",\n  Ǖ: \"U\",\n  ǖ: \"u\",\n  Ǘ: \"U\",\n  ǘ: \"u\",\n  Ǚ: \"U\",\n  ǚ: \"u\",\n  Ǜ: \"U\",\n  ǜ: \"u\",\n  Ứ: \"U\",\n  ứ: \"u\",\n  Ṹ: \"U\",\n  ṹ: \"u\",\n  Ǻ: \"A\",\n  ǻ: \"a\",\n  Ǽ: \"AE\",\n  ǽ: \"ae\",\n  Ǿ: \"O\",\n  ǿ: \"o\",\n  Þ: \"TH\",\n  þ: \"th\",\n  Ṕ: \"P\",\n  ṕ: \"p\",\n  Ṥ: \"S\",\n  ṥ: \"s\",\n  X́: \"X\",\n  x́: \"x\",\n  Ѓ: \"Г\",\n  ѓ: \"г\",\n  Ќ: \"К\",\n  ќ: \"к\",\n  A̋: \"A\",\n  a̋: \"a\",\n  E̋: \"E\",\n  e̋: \"e\",\n  I̋: \"I\",\n  i̋: \"i\",\n  Ǹ: \"N\",\n  ǹ: \"n\",\n  Ồ: \"O\",\n  ồ: \"o\",\n  Ṑ: \"O\",\n  ṑ: \"o\",\n  Ừ: \"U\",\n  ừ: \"u\",\n  Ẁ: \"W\",\n  ẁ: \"w\",\n  Ỳ: \"Y\",\n  ỳ: \"y\",\n  Ȁ: \"A\",\n  ȁ: \"a\",\n  Ȅ: \"E\",\n  ȅ: \"e\",\n  Ȉ: \"I\",\n  ȉ: \"i\",\n  Ȍ: \"O\",\n  ȍ: \"o\",\n  Ȑ: \"R\",\n  ȑ: \"r\",\n  Ȕ: \"U\",\n  ȕ: \"u\",\n  B̌: \"B\",\n  b̌: \"b\",\n  Č̣: \"C\",\n  č̣: \"c\",\n  Ê̌: \"E\",\n  ê̌: \"e\",\n  F̌: \"F\",\n  f̌: \"f\",\n  Ǧ: \"G\",\n  ǧ: \"g\",\n  Ȟ: \"H\",\n  ȟ: \"h\",\n  J̌: \"J\",\n  ǰ: \"j\",\n  Ǩ: \"K\",\n  ǩ: \"k\",\n  M̌: \"M\",\n  m̌: \"m\",\n  P̌: \"P\",\n  p̌: \"p\",\n  Q̌: \"Q\",\n  q̌: \"q\",\n  Ř̩: \"R\",\n  ř̩: \"r\",\n  Ṧ: \"S\",\n  ṧ: \"s\",\n  V̌: \"V\",\n  v̌: \"v\",\n  W̌: \"W\",\n  w̌: \"w\",\n  X̌: \"X\",\n  x̌: \"x\",\n  Y̌: \"Y\",\n  y̌: \"y\",\n  A̧: \"A\",\n  a̧: \"a\",\n  B̧: \"B\",\n  b̧: \"b\",\n  Ḑ: \"D\",\n  ḑ: \"d\",\n  Ȩ: \"E\",\n  ȩ: \"e\",\n  Ɛ̧: \"E\",\n  ɛ̧: \"e\",\n  Ḩ: \"H\",\n  ḩ: \"h\",\n  I̧: \"I\",\n  i̧: \"i\",\n  Ɨ̧: \"I\",\n  ɨ̧: \"i\",\n  M̧: \"M\",\n  m̧: \"m\",\n  O̧: \"O\",\n  o̧: \"o\",\n  Q̧: \"Q\",\n  q̧: \"q\",\n  U̧: \"U\",\n  u̧: \"u\",\n  X̧: \"X\",\n  x̧: \"x\",\n  Z̧: \"Z\",\n  z̧: \"z\"\n};\nvar chars = Object.keys(characterMap).join(\"|\");\nvar allAccents = new RegExp(chars, \"g\");\nfunction removeAccents(str) {\n  return str.replace(allAccents, (match) => {\n    return characterMap[match];\n  });\n}\nvar rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nfunction rankItem(item, value, options) {\n  var _options$threshold;\n  options = options || {};\n  options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;\n  if (!options.accessors) {\n    const rank = getMatchRanking(item, value, options);\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: item,\n      rank,\n      accessorIndex: -1,\n      accessorThreshold: options.threshold,\n      passed: rank >= options.threshold\n    };\n  }\n  const valuesToRank = getAllValuesToRank(item, options.accessors);\n  const rankingInfo = {\n    rankedValue: item,\n    rank: rankings.NO_MATCH,\n    accessorIndex: -1,\n    accessorThreshold: options.threshold,\n    passed: false\n  };\n  for (let i = 0; i < valuesToRank.length; i++) {\n    const rankValue = valuesToRank[i];\n    let newRank = getMatchRanking(rankValue.itemValue, value, options);\n    const {\n      minRanking,\n      maxRanking,\n      threshold = options.threshold\n    } = rankValue.attributes;\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n    newRank = Math.min(newRank, maxRanking);\n    if (newRank >= threshold && newRank > rankingInfo.rank) {\n      rankingInfo.rank = newRank;\n      rankingInfo.passed = true;\n      rankingInfo.accessorIndex = i;\n      rankingInfo.accessorThreshold = threshold;\n      rankingInfo.rankedValue = rankValue.itemValue;\n    }\n  }\n  return rankingInfo;\n}\nfunction getMatchRanking(testString, stringToRank, options) {\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options);\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  }\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  }\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase();\n  if (testString === stringToRank) {\n    return rankings.EQUAL;\n  }\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH;\n  }\n  if (testString.includes(` ${stringToRank}`)) {\n    return rankings.WORD_STARTS_WITH;\n  }\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS;\n  } else if (stringToRank.length === 1) {\n    return rankings.NO_MATCH;\n  }\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM;\n  }\n  return getClosenessRanking(testString, stringToRank);\n}\nfunction getAcronym(string) {\n  let acronym = \"\";\n  const wordsInString = string.split(\" \");\n  wordsInString.forEach((wordInString) => {\n    const splitByHyphenWords = wordInString.split(\"-\");\n    splitByHyphenWords.forEach((splitByHyphenWord) => {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\nfunction getClosenessRanking(testString, stringToRank) {\n  let matchingInOrderCharCount = 0;\n  let charNumber = 0;\n  function findMatchingCharacter(matchChar, string, index) {\n    for (let j = index, J = string.length; j < J; j++) {\n      const stringChar = string[j];\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n    return -1;\n  }\n  function getRanking(spread2) {\n    const spreadPercentage = 1 / spread2;\n    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;\n    return ranking;\n  }\n  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n  charNumber = firstIndex;\n  for (let i = 1, I = stringToRank.length; i < I; i++) {\n    const matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    const found = charNumber > -1;\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n  const spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\nfunction compareItems(a, b) {\n  return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1;\n}\nfunction prepareValueForComparison(value, _ref) {\n  let {\n    keepDiacritics\n  } = _ref;\n  value = `${value}`;\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n  return value;\n}\nfunction getItemValues(item, accessor) {\n  let accessorFn = accessor;\n  if (typeof accessor === \"object\") {\n    accessorFn = accessor.accessor;\n  }\n  const value = accessorFn(item);\n  if (value == null) {\n    return [];\n  }\n  if (Array.isArray(value)) {\n    return value;\n  }\n  return [String(value)];\n}\nfunction getAllValuesToRank(item, accessors) {\n  const allValues = [];\n  for (let j = 0, J = accessors.length; j < J; j++) {\n    const accessor = accessors[j];\n    const attributes = getAccessorAttributes(accessor);\n    const itemValues = getItemValues(item, accessor);\n    for (let i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i],\n        attributes\n      });\n    }\n  }\n  return allValues;\n}\nvar defaultKeyAttributes = {\n  maxRanking: Infinity,\n  minRanking: -Infinity\n};\nfunction getAccessorAttributes(accessor) {\n  if (typeof accessor === \"function\") {\n    return defaultKeyAttributes;\n  }\n  return {\n    ...defaultKeyAttributes,\n    ...accessor\n  };\n}\nexport {\n  compareItems,\n  rankItem,\n  rankings\n};\n/*! Bundled license information:\n\n@tanstack/match-sorter-utils/build/lib/index.mjs:\n  (**\n   * match-sorter-utils\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n  (**\n   * @name match-sorter\n   * @license MIT license.\n   * @copyright (c) 2099 Kent C. Dodds\n   * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n   *)\n*/\n//# sourceMappingURL=@tanstack_match-sorter-utils.js.map\n",
      "start": 1685413275621,
      "end": 1685413275623
    },
    {
      "name": "vite:import-analysis",
      "result": "// node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs\nvar characterMap = {\n  À: \"A\",\n  Á: \"A\",\n  Â: \"A\",\n  Ã: \"A\",\n  Ä: \"A\",\n  Å: \"A\",\n  Ấ: \"A\",\n  Ắ: \"A\",\n  Ẳ: \"A\",\n  Ẵ: \"A\",\n  Ặ: \"A\",\n  Æ: \"AE\",\n  Ầ: \"A\",\n  Ằ: \"A\",\n  Ȃ: \"A\",\n  Ç: \"C\",\n  Ḉ: \"C\",\n  È: \"E\",\n  É: \"E\",\n  Ê: \"E\",\n  Ë: \"E\",\n  Ế: \"E\",\n  Ḗ: \"E\",\n  Ề: \"E\",\n  Ḕ: \"E\",\n  Ḝ: \"E\",\n  Ȇ: \"E\",\n  Ì: \"I\",\n  Í: \"I\",\n  Î: \"I\",\n  Ï: \"I\",\n  Ḯ: \"I\",\n  Ȋ: \"I\",\n  Ð: \"D\",\n  Ñ: \"N\",\n  Ò: \"O\",\n  Ó: \"O\",\n  Ô: \"O\",\n  Õ: \"O\",\n  Ö: \"O\",\n  Ø: \"O\",\n  Ố: \"O\",\n  Ṍ: \"O\",\n  Ṓ: \"O\",\n  Ȏ: \"O\",\n  Ù: \"U\",\n  Ú: \"U\",\n  Û: \"U\",\n  Ü: \"U\",\n  Ý: \"Y\",\n  à: \"a\",\n  á: \"a\",\n  â: \"a\",\n  ã: \"a\",\n  ä: \"a\",\n  å: \"a\",\n  ấ: \"a\",\n  ắ: \"a\",\n  ẳ: \"a\",\n  ẵ: \"a\",\n  ặ: \"a\",\n  æ: \"ae\",\n  ầ: \"a\",\n  ằ: \"a\",\n  ȃ: \"a\",\n  ç: \"c\",\n  ḉ: \"c\",\n  è: \"e\",\n  é: \"e\",\n  ê: \"e\",\n  ë: \"e\",\n  ế: \"e\",\n  ḗ: \"e\",\n  ề: \"e\",\n  ḕ: \"e\",\n  ḝ: \"e\",\n  ȇ: \"e\",\n  ì: \"i\",\n  í: \"i\",\n  î: \"i\",\n  ï: \"i\",\n  ḯ: \"i\",\n  ȋ: \"i\",\n  ð: \"d\",\n  ñ: \"n\",\n  ò: \"o\",\n  ó: \"o\",\n  ô: \"o\",\n  õ: \"o\",\n  ö: \"o\",\n  ø: \"o\",\n  ố: \"o\",\n  ṍ: \"o\",\n  ṓ: \"o\",\n  ȏ: \"o\",\n  ù: \"u\",\n  ú: \"u\",\n  û: \"u\",\n  ü: \"u\",\n  ý: \"y\",\n  ÿ: \"y\",\n  Ā: \"A\",\n  ā: \"a\",\n  Ă: \"A\",\n  ă: \"a\",\n  Ą: \"A\",\n  ą: \"a\",\n  Ć: \"C\",\n  ć: \"c\",\n  Ĉ: \"C\",\n  ĉ: \"c\",\n  Ċ: \"C\",\n  ċ: \"c\",\n  Č: \"C\",\n  č: \"c\",\n  C̆: \"C\",\n  c̆: \"c\",\n  Ď: \"D\",\n  ď: \"d\",\n  Đ: \"D\",\n  đ: \"d\",\n  Ē: \"E\",\n  ē: \"e\",\n  Ĕ: \"E\",\n  ĕ: \"e\",\n  Ė: \"E\",\n  ė: \"e\",\n  Ę: \"E\",\n  ę: \"e\",\n  Ě: \"E\",\n  ě: \"e\",\n  Ĝ: \"G\",\n  Ǵ: \"G\",\n  ĝ: \"g\",\n  ǵ: \"g\",\n  Ğ: \"G\",\n  ğ: \"g\",\n  Ġ: \"G\",\n  ġ: \"g\",\n  Ģ: \"G\",\n  ģ: \"g\",\n  Ĥ: \"H\",\n  ĥ: \"h\",\n  Ħ: \"H\",\n  ħ: \"h\",\n  Ḫ: \"H\",\n  ḫ: \"h\",\n  Ĩ: \"I\",\n  ĩ: \"i\",\n  Ī: \"I\",\n  ī: \"i\",\n  Ĭ: \"I\",\n  ĭ: \"i\",\n  Į: \"I\",\n  į: \"i\",\n  İ: \"I\",\n  ı: \"i\",\n  Ĳ: \"IJ\",\n  ĳ: \"ij\",\n  Ĵ: \"J\",\n  ĵ: \"j\",\n  Ķ: \"K\",\n  ķ: \"k\",\n  Ḱ: \"K\",\n  ḱ: \"k\",\n  K̆: \"K\",\n  k̆: \"k\",\n  Ĺ: \"L\",\n  ĺ: \"l\",\n  Ļ: \"L\",\n  ļ: \"l\",\n  Ľ: \"L\",\n  ľ: \"l\",\n  Ŀ: \"L\",\n  ŀ: \"l\",\n  Ł: \"l\",\n  ł: \"l\",\n  Ḿ: \"M\",\n  ḿ: \"m\",\n  M̆: \"M\",\n  m̆: \"m\",\n  Ń: \"N\",\n  ń: \"n\",\n  Ņ: \"N\",\n  ņ: \"n\",\n  Ň: \"N\",\n  ň: \"n\",\n  ŉ: \"n\",\n  N̆: \"N\",\n  n̆: \"n\",\n  Ō: \"O\",\n  ō: \"o\",\n  Ŏ: \"O\",\n  ŏ: \"o\",\n  Ő: \"O\",\n  ő: \"o\",\n  Œ: \"OE\",\n  œ: \"oe\",\n  P̆: \"P\",\n  p̆: \"p\",\n  Ŕ: \"R\",\n  ŕ: \"r\",\n  Ŗ: \"R\",\n  ŗ: \"r\",\n  Ř: \"R\",\n  ř: \"r\",\n  R̆: \"R\",\n  r̆: \"r\",\n  Ȓ: \"R\",\n  ȓ: \"r\",\n  Ś: \"S\",\n  ś: \"s\",\n  Ŝ: \"S\",\n  ŝ: \"s\",\n  Ş: \"S\",\n  Ș: \"S\",\n  ș: \"s\",\n  ş: \"s\",\n  Š: \"S\",\n  š: \"s\",\n  Ţ: \"T\",\n  ţ: \"t\",\n  ț: \"t\",\n  Ț: \"T\",\n  Ť: \"T\",\n  ť: \"t\",\n  Ŧ: \"T\",\n  ŧ: \"t\",\n  T̆: \"T\",\n  t̆: \"t\",\n  Ũ: \"U\",\n  ũ: \"u\",\n  Ū: \"U\",\n  ū: \"u\",\n  Ŭ: \"U\",\n  ŭ: \"u\",\n  Ů: \"U\",\n  ů: \"u\",\n  Ű: \"U\",\n  ű: \"u\",\n  Ų: \"U\",\n  ų: \"u\",\n  Ȗ: \"U\",\n  ȗ: \"u\",\n  V̆: \"V\",\n  v̆: \"v\",\n  Ŵ: \"W\",\n  ŵ: \"w\",\n  Ẃ: \"W\",\n  ẃ: \"w\",\n  X̆: \"X\",\n  x̆: \"x\",\n  Ŷ: \"Y\",\n  ŷ: \"y\",\n  Ÿ: \"Y\",\n  Y̆: \"Y\",\n  y̆: \"y\",\n  Ź: \"Z\",\n  ź: \"z\",\n  Ż: \"Z\",\n  ż: \"z\",\n  Ž: \"Z\",\n  ž: \"z\",\n  ſ: \"s\",\n  ƒ: \"f\",\n  Ơ: \"O\",\n  ơ: \"o\",\n  Ư: \"U\",\n  ư: \"u\",\n  Ǎ: \"A\",\n  ǎ: \"a\",\n  Ǐ: \"I\",\n  ǐ: \"i\",\n  Ǒ: \"O\",\n  ǒ: \"o\",\n  Ǔ: \"U\",\n  ǔ: \"u\",\n  Ǖ: \"U\",\n  ǖ: \"u\",\n  Ǘ: \"U\",\n  ǘ: \"u\",\n  Ǚ: \"U\",\n  ǚ: \"u\",\n  Ǜ: \"U\",\n  ǜ: \"u\",\n  Ứ: \"U\",\n  ứ: \"u\",\n  Ṹ: \"U\",\n  ṹ: \"u\",\n  Ǻ: \"A\",\n  ǻ: \"a\",\n  Ǽ: \"AE\",\n  ǽ: \"ae\",\n  Ǿ: \"O\",\n  ǿ: \"o\",\n  Þ: \"TH\",\n  þ: \"th\",\n  Ṕ: \"P\",\n  ṕ: \"p\",\n  Ṥ: \"S\",\n  ṥ: \"s\",\n  X́: \"X\",\n  x́: \"x\",\n  Ѓ: \"Г\",\n  ѓ: \"г\",\n  Ќ: \"К\",\n  ќ: \"к\",\n  A̋: \"A\",\n  a̋: \"a\",\n  E̋: \"E\",\n  e̋: \"e\",\n  I̋: \"I\",\n  i̋: \"i\",\n  Ǹ: \"N\",\n  ǹ: \"n\",\n  Ồ: \"O\",\n  ồ: \"o\",\n  Ṑ: \"O\",\n  ṑ: \"o\",\n  Ừ: \"U\",\n  ừ: \"u\",\n  Ẁ: \"W\",\n  ẁ: \"w\",\n  Ỳ: \"Y\",\n  ỳ: \"y\",\n  Ȁ: \"A\",\n  ȁ: \"a\",\n  Ȅ: \"E\",\n  ȅ: \"e\",\n  Ȉ: \"I\",\n  ȉ: \"i\",\n  Ȍ: \"O\",\n  ȍ: \"o\",\n  Ȑ: \"R\",\n  ȑ: \"r\",\n  Ȕ: \"U\",\n  ȕ: \"u\",\n  B̌: \"B\",\n  b̌: \"b\",\n  Č̣: \"C\",\n  č̣: \"c\",\n  Ê̌: \"E\",\n  ê̌: \"e\",\n  F̌: \"F\",\n  f̌: \"f\",\n  Ǧ: \"G\",\n  ǧ: \"g\",\n  Ȟ: \"H\",\n  ȟ: \"h\",\n  J̌: \"J\",\n  ǰ: \"j\",\n  Ǩ: \"K\",\n  ǩ: \"k\",\n  M̌: \"M\",\n  m̌: \"m\",\n  P̌: \"P\",\n  p̌: \"p\",\n  Q̌: \"Q\",\n  q̌: \"q\",\n  Ř̩: \"R\",\n  ř̩: \"r\",\n  Ṧ: \"S\",\n  ṧ: \"s\",\n  V̌: \"V\",\n  v̌: \"v\",\n  W̌: \"W\",\n  w̌: \"w\",\n  X̌: \"X\",\n  x̌: \"x\",\n  Y̌: \"Y\",\n  y̌: \"y\",\n  A̧: \"A\",\n  a̧: \"a\",\n  B̧: \"B\",\n  b̧: \"b\",\n  Ḑ: \"D\",\n  ḑ: \"d\",\n  Ȩ: \"E\",\n  ȩ: \"e\",\n  Ɛ̧: \"E\",\n  ɛ̧: \"e\",\n  Ḩ: \"H\",\n  ḩ: \"h\",\n  I̧: \"I\",\n  i̧: \"i\",\n  Ɨ̧: \"I\",\n  ɨ̧: \"i\",\n  M̧: \"M\",\n  m̧: \"m\",\n  O̧: \"O\",\n  o̧: \"o\",\n  Q̧: \"Q\",\n  q̧: \"q\",\n  U̧: \"U\",\n  u̧: \"u\",\n  X̧: \"X\",\n  x̧: \"x\",\n  Z̧: \"Z\",\n  z̧: \"z\"\n};\nvar chars = Object.keys(characterMap).join(\"|\");\nvar allAccents = new RegExp(chars, \"g\");\nfunction removeAccents(str) {\n  return str.replace(allAccents, (match) => {\n    return characterMap[match];\n  });\n}\nvar rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nfunction rankItem(item, value, options) {\n  var _options$threshold;\n  options = options || {};\n  options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;\n  if (!options.accessors) {\n    const rank = getMatchRanking(item, value, options);\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: item,\n      rank,\n      accessorIndex: -1,\n      accessorThreshold: options.threshold,\n      passed: rank >= options.threshold\n    };\n  }\n  const valuesToRank = getAllValuesToRank(item, options.accessors);\n  const rankingInfo = {\n    rankedValue: item,\n    rank: rankings.NO_MATCH,\n    accessorIndex: -1,\n    accessorThreshold: options.threshold,\n    passed: false\n  };\n  for (let i = 0; i < valuesToRank.length; i++) {\n    const rankValue = valuesToRank[i];\n    let newRank = getMatchRanking(rankValue.itemValue, value, options);\n    const {\n      minRanking,\n      maxRanking,\n      threshold = options.threshold\n    } = rankValue.attributes;\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n    newRank = Math.min(newRank, maxRanking);\n    if (newRank >= threshold && newRank > rankingInfo.rank) {\n      rankingInfo.rank = newRank;\n      rankingInfo.passed = true;\n      rankingInfo.accessorIndex = i;\n      rankingInfo.accessorThreshold = threshold;\n      rankingInfo.rankedValue = rankValue.itemValue;\n    }\n  }\n  return rankingInfo;\n}\nfunction getMatchRanking(testString, stringToRank, options) {\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options);\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  }\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  }\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase();\n  if (testString === stringToRank) {\n    return rankings.EQUAL;\n  }\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH;\n  }\n  if (testString.includes(` ${stringToRank}`)) {\n    return rankings.WORD_STARTS_WITH;\n  }\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS;\n  } else if (stringToRank.length === 1) {\n    return rankings.NO_MATCH;\n  }\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM;\n  }\n  return getClosenessRanking(testString, stringToRank);\n}\nfunction getAcronym(string) {\n  let acronym = \"\";\n  const wordsInString = string.split(\" \");\n  wordsInString.forEach((wordInString) => {\n    const splitByHyphenWords = wordInString.split(\"-\");\n    splitByHyphenWords.forEach((splitByHyphenWord) => {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\nfunction getClosenessRanking(testString, stringToRank) {\n  let matchingInOrderCharCount = 0;\n  let charNumber = 0;\n  function findMatchingCharacter(matchChar, string, index) {\n    for (let j = index, J = string.length; j < J; j++) {\n      const stringChar = string[j];\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n    return -1;\n  }\n  function getRanking(spread2) {\n    const spreadPercentage = 1 / spread2;\n    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;\n    return ranking;\n  }\n  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n  charNumber = firstIndex;\n  for (let i = 1, I = stringToRank.length; i < I; i++) {\n    const matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    const found = charNumber > -1;\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n  const spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\nfunction compareItems(a, b) {\n  return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1;\n}\nfunction prepareValueForComparison(value, _ref) {\n  let {\n    keepDiacritics\n  } = _ref;\n  value = `${value}`;\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n  return value;\n}\nfunction getItemValues(item, accessor) {\n  let accessorFn = accessor;\n  if (typeof accessor === \"object\") {\n    accessorFn = accessor.accessor;\n  }\n  const value = accessorFn(item);\n  if (value == null) {\n    return [];\n  }\n  if (Array.isArray(value)) {\n    return value;\n  }\n  return [String(value)];\n}\nfunction getAllValuesToRank(item, accessors) {\n  const allValues = [];\n  for (let j = 0, J = accessors.length; j < J; j++) {\n    const accessor = accessors[j];\n    const attributes = getAccessorAttributes(accessor);\n    const itemValues = getItemValues(item, accessor);\n    for (let i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i],\n        attributes\n      });\n    }\n  }\n  return allValues;\n}\nvar defaultKeyAttributes = {\n  maxRanking: Infinity,\n  minRanking: -Infinity\n};\nfunction getAccessorAttributes(accessor) {\n  if (typeof accessor === \"function\") {\n    return defaultKeyAttributes;\n  }\n  return {\n    ...defaultKeyAttributes,\n    ...accessor\n  };\n}\nexport {\n  compareItems,\n  rankItem,\n  rankings\n};\n/*! Bundled license information:\n\n@tanstack/match-sorter-utils/build/lib/index.mjs:\n  (**\n   * match-sorter-utils\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   *)\n  (**\n   * @name match-sorter\n   * @license MIT license.\n   * @copyright (c) 2099 Kent C. Dodds\n   * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n   *)\n*/\n//# sourceMappingURL=@tanstack_match-sorter-utils.js.map\n",
      "start": 1685413275623,
      "end": 1685413275623,
      "order": "normal"
    }
  ]
}
